from random import randrange
from copy import deepcopy
import multiprocessing
import time

# short function for printing matrices
def print_matrix(matrix, name):
    print(name + ": ")
    for row in matrix:
        print(row)

# short function to print a seperation (for better looks)
def print_seperation():
    print("---------------------------------------------------------------------------------")




print("please enter your matrix size n for the nxn matrices")
print("(the values of the cells will be autogenerated)\n")

# gets the matrix_size input and validates it
matrix_size = input("n: ")
if matrix_size == "":
    matrix_size = 300
    print("set matrix size to default (",matrix_size,")")
else:
    matrix_size = int(matrix_size)

# generates the matrices A and B to multiply with each other and a destination matrix C (to fill with the result)
A = [[ randrange(5) for i in range(matrix_size)] for j in range(matrix_size)]
B = [[ randrange(5) for i in range(matrix_size)] for j in range(matrix_size)]
C = deepcopy(A)

# print_matrix(A, "A")
# print_matrix(B, "B")

# gets the type of matrix multiplication and validates it
print("\nchoose between: serial matrix mult(1), parallel matrix mult(2)\n")
serial_parallel = input("choice: ")
if serial_parallel == "" or int(serial_parallel) < 1 or int(serial_parallel) > 2:
    serial_parallel = "1"
    print("set mode to default -> serial matrix mult")

# if the matrix multiplication is parallel this if statement prompts for the number of cpu's to calculate on
cpus = 1
if(serial_parallel == "2"):
    print("\nhow many CPU's do you have/ want to use for your parallel calcualtion? (enter to use systemmax)")
    cpus = input("choice: ")
    if cpus == "":
        cpus = multiprocessing.cpu_count()
        print("set cpus to system max (",cpus,"cpus )")
    else:
        cpus = int(cpus)

print_seperation()

# serial matrix multiplication
if serial_parallel == "1":
    print("starting matrix multiplication with serial tripple loop")
    start = time.time()
    
    # the tripple for-loop from the elaboration
    for row in range(matrix_size):
        # print(row, "from", matrix_size, "rows done", end="\r") <-- progressbar 
        for column in range (matrix_size):
            C[row][column] = 0
            for x in range(matrix_size):
                C[row][column] = C[row][column] + (A[row][x] * B[x][column])

    end = time.time()

    print_seperation()
    print("calculation completet in " + str(end-start) + " seconds")
    print_seperation()

    # print_matrix(C, "solution")
                    

# parallel matrix multiplikation
if serial_parallel == "2":
    print("starting matrix multiplication with parallel tripple loop")

    # function to calculate one cell in the matrix 
    # the innermost loop of our tripple loop which can not be parallelised more 
    def calculate_cell(pos):
        row = pos[0]
        column = pos[1]
        cell = 0
        for x in range(matrix_size):
            cell = cell + (A[row][x] * B[x][column])
        return (row, column, cell)

    start = time.time()
    
    # listing all cells to be calculated
    # basicly the outer loops of our tripple loop
    cells = []
    for row in range(matrix_size):
        for column in range (matrix_size):
            cells.append((row, column))

    # creates a new processpool which can use the specified number of cpus
    processpool = multiprocessing.Pool(cpus)

    # the processpool.map is a parallel implementation of the map function and
    # calls the calculate_cell function for every cell 
    # (couldtalke lots of ram maybe use imap to preset chunksize)
    results = processpool.map(calculate_cell, cells)
    # closes the processpool -> no more tasks can be assigned
    processpool.close()
    # waits for all processes to be finished so we can use the result
    # -> like the sync keyword described in the elaboration
    processpool.join()

    #takes our array of results and puts together the result matrix
    for result in results:
        C[result[0]][result[1]] = result[2]

    end = time.time()

    # print_matrix(C, "solution")
    print_seperation()
    print("calculation completet in " + str(end-start) + " seconds")
    print_seperation()